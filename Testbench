`timescale 1ns / 1ps

module tb_seq_detector_1011_moore_overlap;

    // Testbench signals
    reg clk;
    reg rst_n;
    reg data_in;
    wire detect_out;
    
    // Clock period
    localparam CLK_PERIOD = 10;
    
    // Instantiate the DUT (Design Under Test)
    seq_detector_1011_moore_overlap dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .detect_out(detect_out)
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    // Test stimulus
    initial begin
        // Initialize VCD dump for waveform viewing
        $dumpfile("seq_detector_1011_moore_overlap.vcd");
        $dumpvars(0, tb_seq_detector_1011_moore_overlap);
        
        // Initialize signals
        rst_n = 0;
        data_in = 0;
        
        // Display header
        $display("========================================");
        $display("1011 Overlapping Sequence Detector Test");
        $display("========================================");
        $display("Time\tReset\tInput\tDetect\tState");
        $display("----------------------------------------");
        
        // Apply reset
        #(CLK_PERIOD * 2);
        rst_n = 1;
        #(CLK_PERIOD);
        
        // Test Case 1: Basic detection - "1011"
        $display("\n--- Test Case 1: Basic Pattern 1011 ---");
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT
        #(CLK_PERIOD);
        
        // Test Case 2: False pattern - "1001"
        $display("\n--- Test Case 2: False Pattern 1001 ---");
        reset_dut();
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(0); // 100 -> back to IDLE
        send_bit(1); // 1
        #(CLK_PERIOD);
        
        // Test Case 3: Overlapping detection - "10110111"
        // Should detect at positions: 1011 and 1011 (overlapping)
        $display("\n--- Test Case 3: Overlapping Pattern 10110111 ---");
        reset_dut();
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT #1
        send_bit(0); // 10 (reused last '1' and new '0')
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT #2
        send_bit(1); // 1 (new sequence starts)
        #(CLK_PERIOD);
        
        // Test Case 4: Multiple overlapping - "101101011"
        $display("\n--- Test Case 4: Multiple Overlapping 101101011 ---");
        reset_dut();
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT #1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(0); // 1010 -> back to S10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT #2
        #(CLK_PERIOD);
        
        // Test Case 5: Consecutive 1s - "111111"
        $display("\n--- Test Case 5: Consecutive 1s ---");
        reset_dut();
        send_bit(1);
        send_bit(1);
        send_bit(1);
        send_bit(1);
        send_bit(1);
        send_bit(1);
        #(CLK_PERIOD);
        
        // Test Case 6: Consecutive 0s - "000000"
        $display("\n--- Test Case 6: Consecutive 0s ---");
        reset_dut();
        send_bit(0);
        send_bit(0);
        send_bit(0);
        send_bit(0);
        send_bit(0);
        send_bit(0);
        #(CLK_PERIOD);
        
        // Test Case 7: Pattern with noise - "010110111010"
        $display("\n--- Test Case 7: Pattern with Noise ---");
        reset_dut();
        send_bit(0); // 0
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(0); // 1010
        #(CLK_PERIOD);
        
        // Test Case 8: Reset during operation
        $display("\n--- Test Case 8: Reset During Detection ---");
        reset_dut();
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        // Apply reset before completion
        rst_n = 0;
        #(CLK_PERIOD);
        rst_n = 1;
        #(CLK_PERIOD);
        send_bit(1); // Start fresh
        send_bit(0);
        send_bit(1);
        send_bit(1); // 1011 -> DETECT
        #(CLK_PERIOD);
        
        // Test Case 9: Back-to-back detections
        $display("\n--- Test Case 9: Back-to-Back Detections ---");
        reset_dut();
        send_bit(1); // 1
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT
        send_bit(1); // 1 (from S1011 to S1)
        send_bit(0); // 10
        send_bit(1); // 101
        send_bit(1); // 1011 -> DETECT
        #(CLK_PERIOD);
        
        // Summary
        $display("\n========================================");
        $display("All test cases completed!");
        $display("========================================");
        
        #(CLK_PERIOD * 5);
        $finish;
    end
    
    // Task to send a single bit
    task send_bit(input bit_val);
        begin
            @(posedge clk);
            data_in = bit_val;
            #1; // Small delay for display
            $display("%0t\t%b\t%b\t%b\t%b", 
                     $time, rst_n, data_in, detect_out, dut.current_state);
        end
    endtask
    
    // Task to reset the DUT
    task reset_dut();
        begin
            @(posedge clk);
            rst_n = 0;
            #(CLK_PERIOD);
            rst_n = 1;
            data_in = 0;
            #(CLK_PERIOD);
        end
    endtask
    
    // Monitor for detection events
    always @(posedge clk) begin
        if (detect_out) begin
            $display(">>> DETECTION at time %0t <<<", $time);
        end
    end
    
    // Watchdog timer (prevent infinite simulation)
    initial begin
        #10000;
        $display("ERROR: Simulation timeout!");
        $finish;
    end

endmodule
